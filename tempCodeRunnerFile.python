# graph = {
#     0: [1, 4],
#     1: [0, 2, 3,4],
#     2: [1, 3],
#     3: [1, 2, 4],
#     4: [0, 1,3]
# }

# def print_graph(graph):
#     for node in graph:
#         print(f"Node {node} is conNeCt with: {graph[node]}")

# print_graph(graph)



# *****************1.2******************8
# from collections import deque  # Queue use karne ke liye

# # Graph ko dictionary ki form mein define karna
# tree = {
#     'A': ['B', 'F', 'D', 'E'],
#     'B': ['K', 'J'],
#     'F': [],
#     'D': ['G'],   # G is goal
#     'E': ['C', 'H', 'I'],
#     'K': ['N', 'M'],
#     'J': [],
#     'G': [],  # Goal Node
#     'C': [],
#     'H': [],
#     'I': ['L'],
#     'N': [],
#     'M': [],
#     'L': []
# }

# # BFS function jo graph traversal karega
# def bfs(tree, start, goal):
#     queue = deque([start])  # Pehli node (A) ko queue mein dal diya
#     visited = set()  # Track karne ke liye ke konsa node visit ho chuka hai

#     while queue:
#         node = queue.popleft()  # Queue ke front se node nikalo
#         print(f"Visiting: {node}")  # Jo node visit ho raha hai usko print karo

#         if node == goal:  # Agar goal mil gaya toh search stop kar do
#             print(f"Goal node '{goal}' found!")
#             return  

#         visited.add(node)  # Node ko visited list mein daal do

#         # Ab us node ke children ko queue mein dal do
#         for child in tree[node]:
#             if child not in visited:
#                 queue.append(child)  

# # Start BFS from A to find G
# bfs(tree, 'A', 'G')



#***************************1.3***************
# from collections import deque

# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

# def level_order_traversal(root):
#     if not root:
#         return []

#     result = []
#     queue = deque([root])  # Start with the root node

#     while queue:
#         level_size = len(queue)  # Number of nodes at the current level
#         level_nodes = []  # Store values of current level nodes

#         for _ in range(level_size):
#             node = queue.popleft()  # Remove node from queue
#             level_nodes.append(node.val)

#             # Add child nodes to queue for the next level
#             if node.left:
#                 queue.append(node.left)
#             if node.right:
#                 queue.append(node.right)

#         result.append(level_nodes)  # Store the level in result

#     return result

# # Example Binary Tree
# root = TreeNode(1)
# root.left = TreeNode(2)
# root.right = TreeNode(3)
# root.left.left = TreeNode(4)
# root.left.right = TreeNode(5)

# # Calling the function
# print("Level order traversal:", level_order_traversal(root))


# 1.4

from collections import deque

def shortest_path(maze):
    # Maze ki rows aur columns ka pata lagao
    n = len(maze)
    m = len(maze[0])
    
    # Agar start ya end block hai to -1 return karo
    if maze[0][0] == 1 or maze[n-1][m-1] == 1:
        return -1
    
    # BFS ke liye queue banao
    queue = deque()
    queue.append((0, 0, 1))  # (row, column, distance)
    
    # Visited cells track karne ke liye ek set banao
    visited = set()
    visited.add((0, 0))
    
    # Movement ke liye direction vectors
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        row, col, steps = queue.popleft()
        
        # Agar destination par pahunch gaye to steps return karo
        if row == n-1 and col == m-1:
            return steps
        
        # Charon directions me move karne ka check
        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc
            
            # Check karo ke cell valid hai ya nahi
            if 0 <= new_row < n and 0 <= new_col < m and maze[new_row][new_col] == 0 and (new_row, new_col) not in visited:
                queue.append((new_row, new_col, steps + 1))
                visited.add((new_row, new_col))
    
    # Agar koi path nahi mila to -1 return karo
    return -1

# Example input
grid = [
    [0, 0, 1, 0],
    [1, 0, 1, 0],
    [0, 0, 0, 0],
    [1, 1, 0, 0]
]

# Function call aur result print karna
result = shortest_path(grid)
print("The shortest path length is:", result)
